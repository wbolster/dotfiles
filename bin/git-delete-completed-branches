#!/bin/sh

set -eu

main() {
    target="${1-}"

    # Ensure this is run inside a git repo.
    git rev-parse --show-toplevel > /dev/null

    if ! default_upstream=$(get_default_upstream); then
        default_upstream=''
    fi

    current_branch=$(git symbolic-ref --short HEAD)

    echo
    print_divider
    echo

    for branch in $(list_branches); do
        printf "ğŸ” Found local branch $(color yellow)â€˜%sâ€™$(color off) (%s)\n" "$branch" "$(git rev-parse --short "$branch")"

        if [ "$branch" = "$current_branch" ]; then
            upstream=''
            printf "ğŸ“Œ Refusing to operate on currently checked out branch; skipping\n"
        elif [ -n "$target" ]; then
            # FIXME: does not work with a branch name
            upstream=$(git symbolic-ref --short "$target")
            message="ğŸ¯ Comparing against explicit target branch"
        elif upstream=$(get_branch_upstream "${branch}"); then
            # Branch has a configured upstream.
            message="ğŸ†™ Comparing against configured upstream"
        elif [ -n "$default_upstream" ]; then
            upstream="$default_upstream"
            message="ğŸ†™ No upstream configured; comparing against default remote HEAD"
        else
            upstream=''
            printf "ğŸ˜± Cannot determine upstream; skipping\n"
        fi

        if [ -n "$upstream" ]; then
            printf "%s $(color yellow)â€˜%sâ€™$(color off) (%s)\n" "$message" "$upstream" "$(git rev-parse --short "$upstream")"

            if details=$(branch_fully_present_in_target "$branch" "$upstream"); then
                printf 'âœ… Local changes included upstream (%s)\n' "$details"
                if ask_confirmation "ğŸš® Delete branch â€˜${branch}â€™?"; then
                    color red
                    git branch --delete --force --quiet "$branch"
                    color off
                fi
            else
                printf "âŒ Local changes not fully contained in upstream branch; $(color green)keeping branch$(color off)%s\n" ''
                echo 'ğŸ’¡ Commits not in upstream branch:'
                echo
                git log --format='tformat:    %h %s' "${upstream}..${branch}"
                echo
                echo "ğŸ“ƒ Details:"
                echo
                printf '    git log %s..%s\n' "$upstream" "$branch"
                echo
                printf '    git diff %s...%s\n' "$upstream" "$branch"
                echo
            fi
        fi

        if branch_exists "$branch"; then
            printf "ğŸŒ± $(color green)Kept local branch â€˜%sâ€™$(color off)\n" "$branch"
        else
            printf "ğŸ’€ $(color red)Deleted branch â€˜%sâ€™$(color off)\n" "$branch"
        fi

        echo
        print_divider
        echo
    done

    echo 'ğŸŒ³ Remaining branches:'
    echo
    print_branches_overview

    echo â€"ğŸ¤“ Happy hacking!"
}

get_default_remote () {
    remotes="$(git remote show)"
    if [ "$(echo "$remotes" | wc -l)" = "1" ]; then
        # If there is a single remote, use it.
        remote=$(echo "$remotes" | head -n 1)
    elif remote=$(git remote show | grep -F -x origin); then
        : # If there is a remote named â€˜originâ€™, use it.
    else
        return 1
    fi
    echo "${remote}"
}

get_default_upstream() {
    git symbolic-ref "refs/remotes/$(get_default_remote)/HEAD"
}

get_branch_upstream() {
    branch="$1" && shift
    git rev-parse --symbolic-full-name "${branch}@{upstream}" 2>/dev/null
}

list_branches() {
    git for-each-ref refs/heads/ \
        --format='%(refname:short)' \
        --sort=refname \
        --sort='authordate'
}

branch_exists() {
    branch="$1" && shift
    git show-ref --verify --quiet "refs/heads/${branch}"
}

branch_sha() {
    branch="$1" && shift
    git rev-parse --short "refs/heads/${branch}"
}

branch_fully_present_in_target() {
    branch="$1" && shift
    target_branch="$1" && shift
    merge_base=$(git merge-base "$target_branch" "$branch")
    branch_tree=$(git rev-parse "${branch}^{tree}")
    target_branch_tree=$(git rev-parse "${target_branch}^{tree}")

    # If branches point to the same tree, by definition no changes are missing.
    if [ "$branch_tree" = "$target_branch_tree" ]; then
        echo "points to same tree"
        return 0
    fi

    # Check normal merges.
    if git merge-base --is-ancestor "$branch" "$target_branch"; then
        echo "branch already merged"
        return 0
    fi

    # Check â€˜squashed mergesâ€™. Make a temporary commit on top of the
    # merge base with all the changes from the branch. Then use â€˜git
    # cherryâ€™ to see if there are any changes missing from the target
    # branch. If that is the case, the output starts with a plus sign.
    # If all changes are already part of the target branch, the output
    # starts with a minus sign.
    commit=$(
        git commit-tree \
            "$branch_tree" \
            -p "$merge_base" \
            -m "Temporary commit to check â€˜${branch}â€™ against â€˜${target_branch}â€™" \
            -m "Merge base: ${merge_base}" \
            -m "Checking: $(git rev-parse "${branch}")" \
            -m "Target: $(git rev-parse "${target_branch}")" \
          )
    if git cherry "$target_branch" "$commit" | grep -q ^-; then
        echo "cherry-picked, squashed, or otherwise included"
        return 0
    fi

    return 1
}

print_branches_overview() {
    for branch in $(list_branches); do
        date=$(git log --max-count=1 --format=%ad "refs/heads/$branch")
        log_args="$branch"
        if upstream=$(get_branch_upstream "${branch}"); then
            log_args="$upstream".."$branch"
        fi

        printf "$(color yellow)%s$(color off) (%s)\n" "$branch" "$date"
        git --no-pager log --max-count=10 --format='tformat:* %s' "$log_args"
        echo
    done
}

ask_confirmation() {
    message="$1"
    printf "%s (y/n) " "$message"  # no newline
    read -r answer
    if [ "$answer" = "y" ]; then
        return 0;
    else
        return 1
    fi
}

print_divider() {
    echo ğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸ ğŸ¦ˆ
}

color() {
    case "$1" in
        red)
            tput setaf 1
            ;;
        green)
            tput setaf 2
            ;;
        yellow)
            tput setaf 3
            ;;
        off)
            tput sgr0
            ;;
        *)
            exit 1
            ;;
    esac
}

main "$@"
